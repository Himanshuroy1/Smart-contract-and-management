// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

contract SimpleAssessment {
    address payable public owner;
    uint256 public balance;

    event Deposit(uint256 amount);
    event Withdraw(uint256 amount);

    struct Player {
        address playerAddress;
        uint256 winnings;
    }

    struct Transaction {
        string resultType;
        uint256 timestamp;
    }

    mapping(address => Player) public players;
    mapping(address => Transaction[]) public transactionHistory;
    Player[] public leaderboard;

    modifier onlyOwner() {
        require(msg.sender == owner, "You are not the owner");
        _;
    }

    constructor() {
        owner = payable(msg.sender);
        balance = 0;
    }

    function getBalance() public view returns (uint256) {
        return balance;
    }

    function deposit() public payable onlyOwner {
        balance += msg.value;
        emit Deposit(msg.value);
    }

    function withdraw(uint256 amount) public onlyOwner {
        require(balance >= amount, "Insufficient balance");
        balance -= amount;
        owner.transfer(amount);
        emit Withdraw(amount);
    }

    function addToLeaderboard(address playerAddress, uint256 amountWon) public {
        players[playerAddress].playerAddress = playerAddress;
        players[playerAddress].winnings += amountWon;

        bool exists = false;
        for (uint256 i = 0; i < leaderboard.length; i++) {
            if (leaderboard[i].playerAddress == playerAddress) {
                leaderboard[i].winnings = players[playerAddress].winnings;
                exists = true;
                break;
            }
        }

        if (!exists) {
            leaderboard.push(players[playerAddress]);
        }
    }

    function getLeaderboard() public view returns (Player[] memory) {
        return leaderboard;
    }

    function addToHistory(address playerAddress, string memory result) public {
        transactionHistory[playerAddress].push(Transaction({
            resultType: result,
            timestamp: block.timestamp
        }));
    }

    function getHistory(address playerAddress) public view returns (Transaction[] memory) {
        return transactionHistory[playerAddress];
    }
}
